// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/// @title EvolvableNFT
/// @notice NFT where holders can upgrade their NFT to higher levels
contract EvolvableNFT is ERC721URIStorage, Ownable {
uint256 public nextTokenId;

```
struct NFTData {
    uint8 level;
}

mapping(uint256 => NFTData) public tokenData;

event Minted(address indexed to, uint256 indexed tokenId);
event Upgraded(address indexed owner, uint256 indexed tokenId, uint8 newLevel);

constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}

/// @notice Owner mints base-level NFT
function mint(address to, string calldata uri) external onlyOwner returns (uint256) {
    uint256 tokenId = nextTokenId++;
    _safeMint(to, tokenId);
    _setTokenURI(tokenId, uri);
    tokenData[tokenId] = NFTData(1); // start at level 1
    emit Minted(to, tokenId);
    return tokenId;
}

/// @notice Holder upgrades their NFT (increase level by 1)
function upgrade(uint256 tokenId, string calldata newURI) external {
    require(ownerOf(tokenId) == msg.sender, "Not owner");
    NFTData storage data = tokenData[tokenId];
    data.level += 1;
    _setTokenURI(tokenId, newURI);
    emit Upgraded(msg.sender, tokenId, data.level);
}

/// @notice Get current level of NFT
function levelOf(uint256 tokenId) external view returns (uint8) {
    return tokenData[tokenId].level;
}
```

}
